package define;

public class API {
/*
  ** API-SDK 
  =>API(Application Programming Interface):응용 프로그램을 만들기 위해서 제공되는 도구들 (함수,클래스,데이터...)
  =>SDK(Software Development Kit): 프로그램을 개발하기 위한 도구들   
  
  JDK(Java Development Kit):자바로 응용프로그램을 개발하도록 해주는 도구 - Java SDK 
  윈도우 프로그램일을 하고자 하면 Windows API나 Windows SDK를 설치해야 합니다. 
  
  카카오 로그인을 만들고자 합니다. 
  제일 먼저 검색해야 하는 것은 kakao API 를 찾아야 합니다. 
  
  ** java.util패키지 
  => 자료구조 클래스와 날짜 그리고 Random클래스를 소유한 패키지 
  => 입출력과 관련된 Scanner 클래스도 존재 
  => java.lang다음으로 많이 사용되는 패키지 
  => 이 패키지는 import되어 있지 않기 때문에 이 패키지의 클래스들을 사용할 때는 패키지 이름까지 기재하던지 
       아니면 import해서  클래스 이름만으로 사용합니다. 
       
  1. Arrays클래스 
  => 배열과 관련된 작업을 수행해주는 클래스 
  => static메소드만 소유하고 있기 때문에 객체를 생성할 필요가 없습니다. 
  => 배열의 내용이 같은지 비교해주는 equals 
  => 복사를 해주는 copy 
  => 데이터를 정렬해주는 sort() - 기본적으로는 Comparable인터페이스가 구현된 클래스의 객체만 정렬이 가능 
      Comparable인터페이스는 크기 비교를 할 수 있는 compareTO라는 메소드를 소유 
      정렬은 크기 비교를 할 수 있을 때 만 가능
 
  Comparable 인터페이스를 implements하지 않은 경우에는 배열과 크기 비교를 할 수 있는 Comparator인터페이스를
  구현한 객체를 대입해서 정렬이 가능합니다. 
  
   => 이분 검색을 수행해서 결과를 리턴하는 binarySearch:이분 검색은 정렬이 된 상태에서만 올바른 결과를 가져 옵니다. 
   정렬된 데이터에서 데이터의 위치를 찾아 주는데 데이터가 존재하지 않으면 음수를 리턴합니다. 
   
   => 데이터를 정렬하는 것은 중요  
   데이터가 2개 이상이면 정렬을 해주는 것이 좋습니다. 
   
   => 배열의 데이터 클래스에 Comparable 인터페이스를 직접 implements하게 되면 하나의 방법으로만 정렬할 수 있습니다.
   
   => Arrays.sort(배열, Comparator 인터페이스를 구현한 객체)을 이용하면 동적으로 정렬을 수행할 수 있습니다. 
   
     데이터 검색 알고리즘 
	  1. 순차검색 
	  => 데이터가 정렬되지 않은 경우 앞에서 부터 순서대로 검색하는 방법 
	  
	  2. 제어검색 
	  => 데이터가 정렬된 경우 사용 
  
		  1) binary search(이분검색) 
		  => 중앙값과 비교해서 작으면 왼쪽 크면 오른쪽 부분에서 검색하는 방법 
		  
		  2) fibonacci Search  
		  =>피보나치 수열을 이용해서 (1,1,2,3,5,8,13,21,34,54...)
		  
		  3) 보간 검색 
		  => 검색할 위치 계산 
		  (검색값 - 최소값) / (최대값-최소값) * 데이터 개수 
		  => 데이터의 분포가 고르지 않으면 검색하는 데 정확하지 않다 
		  
		   4) 	binary Tree검색 
		   => 데이터를 저장할 때 트리이용 
	   
	  3. 블럭  검색 
	  => 블럭끼리는 정렬을 하고 블럭 내부는 정렬 안함
	  
	  4. Hashing 
	  => 가장 빠른 검색 
	  => 함수를 이용해 저장 
	  
   
   2. 인터페이스나 클래스를 상속 받아서 사용하는 방법 - Comparator를 implements 
	   1) 인터페이스를 implements하거나 클래스를 extends해서 새로운 클래스를 만들고 객체를 만드는 방법 
	   class ? implements Comparator{
	       필요한 메소드 오버라이딩 
	   }
	   
	   ? 변수명 = new ? (); 
	   
	   2)anonymous class를 만들어서 사용하는 방법 
	   =>클래스를 만들지 않고 바로 객체를 만들어서 사용하는 방법 
	  Comparable 변수명 = new Comparable() {
	      필요한 메소드 오버라이딩 
	   }; 
  
  3. java에서 객체의 크기 비교를 위해 존재하는 인터페이스 
    1) Comparable인터페이스 
    2) Comparator인터페이스 
    => 위 2개 중 하나의 인터페이스를 구현해야만 데이터를 비교해서 정렬할 수 있습니다.
  
  ** java.util.Collection 인터페이스 
   => 데이터의 모임을 Collection이라고 합니다, 
   => Collection인터페이스를 상속받은 2개의 인터페이스가 있는데 List(데이터를 순서대로 나열, 중복허용 )와 
        Set(데이터를 순서와 상관없이 나열, 중복을 허용하지 않음) 입니다. 
   => 인터페이스에는 List와 Set에서 사용할 메소드의 이름을 만들어 놓았습니다. 
   =>add: 데이터를 추가하는 메소드 
   => remove: 데이터를 제거하는 메소드 
   =>clear: 전체 데이터를 삭제하는 메소드 
   =>size: 데이터의 개수를 리턴하는 메소드  

 ** Enumeration & Iterator 인터페이스 
   Enumeration - > Iterator로 업그레이드 
   데이터의 모임을 순회할 때  인덱스를 이용하지 않고 읽은 곳에 대기하고 있다가 다음 데이터를 빠르게 접근하기 위한
   메소드를 소유한 인터페이스 
   
   1.Enumeration 
   =>boolean hasMoreElements(): 다음 데이터가 있으면 true 없으면 false 
   => E nextElement(): 다음 데이터를 리턴, E는 데이터를 만들때 사용한 Generic자료형입니다. 
   
   2.Iterator 
   => boolean hasNext() 
   => E next() 
   
   **List 인터페이스 
   => 데이터를 순서대로 저장하는 자료구조 인터페이스 
      unsafe        safe
    1. vector -> ArrayList 
	   => 2개의 구조는 같고 Vector는 멀티스레드에 안전하고 ArrayList는 안전하지 않음 
	   => Vector가 Legacy Class입니다, 
	   => 데이터를 물리적으로 연속해서 배치하는 구조 
	   => 크기가 변경이 되기 때문에 추가 및 삭제가 가능합니다. 
	   => 물리적으로 연속이기 때문에 LinkedList에 비해서 접근속도는 빠르지만 중간에 데이터를 삽입하거나 삭제하는
	      경우에는 느리게 동작합니다, 
	      물리적으로 연속해야 하기 때문에 중간에 데이터를 삭제하거나 삽입하면 데이터의 이동이 발생합니다.  
	   
   2. LinkedList 
	  => 데이터를 논리적으로 연속해서 배치하는 구조 
	  => 실제 연속이 아니고 다음 데이터의 위치를 기억하는 구조 
	  => 크기 변경이 가능해서 데이터를 추가 및 삭제할 수 있습니다. 
	  => 삽입과 삭제가 발생하면 실제 데이터의 이동은 없고 링크만 수정하기 때문에 삽입과 삭제 동작이 빠릅니다. 
	  => 데이터가 연속적으로 존재하지 않아서 데이터의 접근속도는 느립니다. 
	  => 읽기를 많이하는경우에느 ArrayList 편집을 많이 하는 경우에는 LinkedList 
	  => 웹 프로그래밍은 삽입과 삭제보다는 읽기를 많이 하기 때문에 ArrayList를 사용하고  응용 프로그램은 삽입과 삭제를 많이
	      하기 때문에 LinkedList를 많이 사용합니다. 
   
  Multi Thread에 Safe: 확인하고 사용  unsafe: 확인 안하고 사용 
   
    3. 생성과 접근 
    =>제너릭이 적용되기때문에 객체를 생성할 때 자료형을 결정해야 합니다. 
    자료형을 결정하지 않으면 경고가 발생합니다. 
    => 전체 데이터를순회하는 것은 빠른 열거를 이용해서 할 수 있습니다. 
    
   4. System.currentTimeMillis(): 1970년 1월 1일 자정이후에 지나온 시간을 1/1000초 단위로 계산해서 
       long로 리턴해 주는 메소드 
       
   5. 엑셀의 표와 유사한 테이블 구조의 데이터 만들기 
   => 하나의 행은 class나 Map으로 만듭니다 
   => 행들의 집합은 배열이나 List로 생성  
   
   ** 연락처와 같은 구조의 테이블 구조를 생성 
   1. 연락처 1개를 저장할 클래스를 생성 
   연락처에는 이름(문자열), 전화번호(문자열), 주소(문자열), 나이(정수)를 저장
    
   ** 게시판과 같은 구조의 테이블 구조를 생성 
   1. 게시판  1개를 저장할 클래스를 생성 
   글번호, 글제목, 글작성자, 글쓴날짜 를 저장
    => 숫자를 문자열로 만드는 것은 거의 문제가 되지 않습니다. 
    => 문자열로 만들어야 하는 것을 숫자로 만들면 문제가 발생할 소지가 많습니다.  
   
   
  
	
  
  
   
 
 
  
 */
}
